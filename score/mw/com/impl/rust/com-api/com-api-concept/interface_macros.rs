/********************************************************************************
 * Copyright (c) 2025 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: Apache-2.0
 ********************************************************************************/

/// Main interface macro that generates Consumer, Producer, and OfferedProducer types
/// along with all necessary trait implementations.
///
/// Automatically generates unique type names from the identifier of macro invocation.
/// For an interface with identifier `{id}`, it generates:
/// - `{id}Interface` - Struct representing the interface with INTERFACE_ID constant
/// - `{id}Consumer<R>` - Consumer implementation with event subscribers
/// - `{id}Producer<R>` - Producer implementation
/// - `{id}OfferedProducer<R>` - Offered producer implementation with event publishers
/// - Implements the `Interface`, `Consumer`, `Producer`, and `OfferedProducer` traits
///  for the respective types.
/// - `Interface_ID` is generated by default as the module path + interface name,
/// but can be overridden by providing a custom UID as a second parameter to the macro.
///
/// Parameters:
/// - Keywords: `interface` followed by the interface identifier and a block of event definitions.
/// - `$id`: Simple identifier used for type name generation (e.g., Vehicle, Engine)
/// - `$event_name`: Event field name
/// - `$event_type`: Event data type
/// Example usage:
/// With default UID generation (module path + interface name):
/// ```ignore
/// mod abc {
///     use com_api_concept::interface;
///     interface!(
///         interface Vehicle {
///             left_tire: Event<Tire>,
///             exhaust: Event<Exhaust>,
///         }
///     );
/// }
/// ```
/// The generated code will include:
/// - `VehicleInterface` struct with `INTERFACE_ID = "abc::Vehicle"`
/// - `VehicleConsumer<R>` struct that implements `Consumer` trait for subscribing to "left_tire" and "exhaust" events.
/// - `VehicleProducer<R>` struct that implements `Producer` trait for producing "left_tire" and "exhaust" events.
/// - `VehicleOfferedProducer<R>` struct that implements `OfferedProducer` trait for offering "left_tire" and "exhaust" events.
///
/// With custom UID:
/// ```ignore
/// mod abc {
///     use com_api_concept::interface;
///     interface!(
///         interface Vehicle, "AbcInterface", {
///             left_tire: Event<Tire>,
///             exhaust: Event<Exhaust>,
///         }
///     );
/// }
/// ```
/// The generated code will include:
/// - `VehicleInterface` struct with `INTERFACE_ID = "AbcInterface"`
/// - `VehicleConsumer<R>` struct that implements `Consumer` trait for subscribing to "left_tire" and "exhaust" events.
/// - `VehicleProducer<R>` struct that implements `Producer` trait for producing "left_tire" and "exhaust" events.
/// - `VehicleOfferedProducer<R>` struct that implements `OfferedProducer` trait for offering "left_tire" and "exhaust" events.

#[macro_export]
macro_rules! interface {
    // Default unique ID based on the module path and interface name
    (interface $id:ident { $($event_name:ident : Event<$event_type:ty>),+ $(,)? }) => {
        $crate::interface_common!($id);
        $crate::interface_consumer!($id, $($event_name, Event<$event_type>),+);
        $crate::interface_producer!($id, $($event_name, Event<$event_type>),+);
    };

    // Custom unique ID provided by the user
    (interface $id:ident, $uid:expr, { $($event_name:ident : Event<$event_type:ty>),+ $(,)? }) => {
        $crate::interface_common!($id, $uid);
        $crate::interface_consumer!($id, $($event_name, Event<$event_type>),+);
        $crate::interface_producer!($id, $($event_name, Event<$event_type>),+);
    };

    (interface $id:ident { $($event_name:ident : Method<$event_type:ty>),+$(,)? }) => {
        compile_error!("Method definitions are not supported in this macro version. Please use Event<T> syntax for defining events.");
    };

    (interface $id:ident { $($event_name:ident : Field<$event_type:ty>),+$(,)? }) => {
        compile_error!("Field definitions are not supported in this macro version. Please use Event<T> syntax for defining events.");
    };
}

/// Macro to create a unique interface struct and implement the Interface trait for it.
///
/// Generates the INTERFACE_ID constant and associated Consumer/Producer types.
/// INTERFACE_ID is generated by default as the module path + interface name,
/// but can be overridden by providing a custom UID as a second parameter to the macro.
#[macro_export]
macro_rules! interface_common {
    // Default: auto ID = module path + type name
    ($id:ident) => {
        $crate::paste! {
            pub struct [<$id Interface>] {}
            impl com_api::Interface for [<$id Interface>] {
                const INTERFACE_ID: &'static str =
                    concat!(module_path!(), "::", stringify!($id));
                type Consumer<R: com_api::Runtime + ?Sized> = [<$id Consumer>]<R>;
                type Producer<R: com_api::Runtime + ?Sized> = [<$id Producer>]<R>;
            }
        }
    };
    // Explicit ID override
    ($id:ident, $uid:expr) => {
        $crate::paste! {
            pub struct [<$id Interface>] {}
            impl com_api::Interface for [<$id Interface>] {
                const INTERFACE_ID: &'static str = $uid;
                type Consumer<R: com_api::Runtime + ?Sized> = [<$id Consumer>]<R>;
                type Producer<R: com_api::Runtime + ?Sized> = [<$id Producer>]<R>;
            }
        }
    };
}

/// Macro to implement the Consumer trait for a given interface ID and its events.
///
/// Generates the Consumer struct with subscribers for each event.
#[macro_export]
macro_rules! interface_consumer {
    ($id:ident, $($event_name:ident, Event<$event_type:ty>),+$(,)?) => {
        $crate::paste! {
            pub struct [<$id Consumer>]<R: com_api::Runtime + ?Sized> {
                $(
                    pub $event_name: R::Subscriber<$event_type>,
                )+
            }

            impl<R: com_api::Runtime + ?Sized> com_api::Consumer<R> for [<$id Consumer>]<R> {
                fn new(instance_info: R::ConsumerInfo) -> Self {
                    [<$id Consumer>] {
                        $(
                            $event_name: R::Subscriber::new(
                                stringify!($event_name),
                                instance_info.clone()
                            ).expect(&format!("Failed to create subscriber for {}", stringify!($event_name))),
                        )+
                    }
                }
            }
        }
    };
}

/// Macro to implement the Producer and OfferedProducer traits for a given interface ID and its events.
///
/// Generates Producer and OfferedProducer structs with publishers for each event.
#[macro_export]
macro_rules! interface_producer {
    ($id:ident, $($event_name:ident, Event<$event_type:ty>),+$(,)?) => {
        $crate::paste! {
            pub struct [<$id Producer>]<R: com_api::Runtime + ?Sized> {
                _runtime: core::marker::PhantomData<R>,
                instance_info: R::ProviderInfo,
            }

            pub struct [<$id OfferedProducer>]<R: com_api::Runtime + ?Sized> {
                $(
                    pub $event_name: R::Publisher<$event_type>,
                )+
                instance_info: R::ProviderInfo,
            }

            impl<R: com_api::Runtime + ?Sized> com_api::Producer<R> for [<$id Producer>]<R> {
                type Interface = [<$id Interface>];
                type OfferedProducer = [<$id OfferedProducer>]<R>;
                fn offer(self) -> com_api::Result<Self::OfferedProducer> {
                    let offered = [<$id OfferedProducer>] {
                        $(
                            $event_name: R::Publisher::new(
                                stringify!($event_name),
                                self.instance_info.clone()
                            ).expect(&format!("Failed to create publisher for {}", stringify!($event_name))),
                        )+
                        instance_info: self.instance_info.clone(),
                    };
                    // Offer the service instance to make it discoverable
                    self.instance_info.offer_service()?;
                    Ok(offered)
                }

                fn new(instance_info: R::ProviderInfo) -> com_api::Result<Self> {
                    Ok([<$id Producer>] {
                        _runtime: core::marker::PhantomData,
                        instance_info,
                    })
                }
            }

            impl<R: com_api::Runtime + ?Sized> com_api::OfferedProducer<R> for [<$id OfferedProducer>]<R> {
                type Interface = [<$id Interface>];
                type Producer = [<$id Producer>]<R>;
                fn unoffer(self) -> com_api::Result<Self::Producer> {
                    let producer = [<$id Producer>] {
                        _runtime: core::marker::PhantomData,
                        instance_info: self.instance_info.clone(),
                    };
                    // Stop offering the service instance to withdraw it from system availability
                    self.instance_info.stop_offer_service()?;
                    Ok(producer)
                }
            }
        }
    };
}

mod tests {
    /// ```
    /// mod my_module {
    ///     use com_api::{interface,CommData, Reloc, ProviderInfo, Subscriber, Publisher};    
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     
    ///     interface!(
    ///         interface Vehicle {
    ///             left_tire: Event<Tire>,
    ///             exhaust: Event<Exhaust>,
    ///         }
    ///     );
    /// }
    /// ```
    /// This will generate the following types and trait implementations:
    /// - `VehicleInterface` struct with `INTERFACE_ID = "my_module::Vehicle"`
    /// - `VehicleConsumer<R>`, `VehicleProducer<R>`, `VehicleOfferedProducer<R>` with appropriate trait implementations for the Vehicle interface.
    #[cfg(doctest)]
    fn interface_macro_with_auto_id() {}

    /// ```
    /// mod my_module {
    ///     use com_api::{interface, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     
    ///     interface!(
    ///         interface Vehicle, "VehicleInterface", {
    ///             left_tire: Event<Tire>,
    ///             exhaust: Event<Exhaust>,
    ///         }
    ///     );
    /// }
    /// ```
    /// This will generate the following types and trait implementations:
    /// - `VehicleInterface` struct with `INTERFACE_ID = "VehicleInterface"`
    /// - `VehicleConsumer<R>`, `VehicleProducer<R>`, `VehicleOfferedProducer<R>` with appropriate trait implementations for the Vehicle interface.
    #[cfg(doctest)]
    fn interface_macro_with_custom_id() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     
    ///     interface!(
    ///         interface Vehicle, "VehicleInterface", {
    ///             left_tire: Method<Tire>,
    ///             exhaust: Method<Exhaust>,
    ///         }
    ///     );
    /// }
    /// ```
    /// This will fail to compile because the macro does not support Method definitions and will produce a compile-time error indicating that Method definitions are not supported.
    #[cfg(doctest)]
    fn interface_macro_with_Method() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     
    ///     interface!(
    ///         interface Vehicle {
    ///             left_tire: Field<Tire>,
    ///             exhaust: Field<Exhaust>,
    ///         }
    ///     );
    /// }
    /// ```
    /// This will fail to compile because the macro does not support Field definitions and will produce a compile-time error indicating that Field definitions are not supported.
    #[cfg(doctest)]
    fn interface_macro_with_Field() {}

    /// ```
    /// mod my_module {
    ///     use com_api::{interface_common, interface_consumer, interface_producer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_common!(Vehicle);
    ///     interface_consumer!(Vehicle, left_tire, Event<Tire>, exhaust, Event<Exhaust>);
    ///     interface_producer!(Vehicle, left_tire, Event<Tire>, exhaust, Event<Exhaust>);
    /// }
    /// ```
    /// This will generate a `VehicleInterface` struct with an `INTERFACE_ID` constant that is automatically generated as the module path plus the interface name (e.g., "my_module::Vehicle").
    /// It will also define associated `Consumer` and `Producer` types for the `VehicleInterface`.
    /// The `VehicleConsumer<R>` struct will implement the `Consumer` trait for the `VehicleInterface`, with subscribers for the `left_tire` and `exhaust` events.
    /// The `VehicleProducer<R>` struct will implement the `Producer` trait for the `VehicleInterface`, with publishers for the `left_tire` and `exhaust` events.
    #[cfg(doctest)]
    fn individual_common_macro_with_auto_id() {}

    /// ```
    /// mod my_module {
    ///     use com_api::{interface_common, interface_consumer, interface_producer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_common!(Vehicle, "CustomVehicleInterface");
    ///     interface_consumer!(Vehicle, left_tire, Event<Tire>, exhaust, Event<Exhaust>);
    ///     interface_producer!(Vehicle, left_tire, Event<Tire>, exhaust, Event<Exhaust>);
    /// }
    /// ```
    /// This will generate a `VehicleInterface` struct with an `INTERFACE_ID` constant set to "CustomVehicleInterface".
    /// It will also define associated `Consumer` and `Producer` types for the `VehicleInterface`.
    /// The `VehicleConsumer<R>` struct will implement the `Consumer` trait for the `VehicleInterface`, with subscribers for the `left_tire` and `exhaust` events.
    /// The `VehicleProducer<R>` struct will implement the `Producer` trait for the `VehicleInterface`, with publishers for the `left_tire` and `exhaust` events.
    #[cfg(doctest)]
    fn individual_macro_with_custom_id() {}

    /// ```compile_fail
    /// mod my_module {
    ///      use com_api::{interface_common, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///      #[derive(Debug, Reloc)]
    ///      #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///    impl CommData for Tire {
    ///        const ID: &'static str = "Tire";
    ///   }
    ///     #[derive(Debug, Reloc)]
    ///    #[repr(C)]
    ///   pub struct Exhaust {}
    ///   impl CommData for Exhaust {
    ///       const ID: &'static str = "Exhaust";
    ///   }
    ///     interface_common!(Vehicle, "CustomVehicleInterface", {
    ///         left_tire: Event<Tire>,
    ///         exhaust: Event<Exhaust>,
    ///     });
    /// }
    /// ```
    /// This will fail to compile because the `interface_common!` macro does not accept event definitions and will produce a compile-time error indicating that the macro does not support event definitions.
    #[cfg(doctest)]
    fn interface_common_macro_with_events() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_common, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_common!(Vehicle, "CustomVehicleInterface", {
    ///         left_tire: Method<Tire>,
    ///         exhaust: Method<Exhaust>,
    ///     });
    /// }
    /// ```
    /// This will fail to compile because the `interface_common!` macro does not accept method definitions and will produce a compile-time error indicating that the macro does not support method definitions.
    #[cfg(doctest)]
    fn interface_common_macro_with_methods() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_common, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_common!(Vehicle, "CustomVehicleInterface", {
    ///         left_tire: Field<Tire>,
    ///         exhaust: Field<Exhaust>,
    ///     });
    /// }
    /// ```
    /// This will fail to compile because the `interface_common!` macro does not accept field definitions and will produce a compile-time error indicating that the macro does not support field definitions.
    #[cfg(doctest)]
    fn interface_common_macro_with_fields() {}

    /// ```
    /// mod my_module {
    ///     use com_api::{interface_consumer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_consumer!(Vehicle, left_tire, Event<Tire>, exhaust, Event<Exhaust>);
    /// }
    /// ```
    /// This will generate a `VehicleConsumer<R>` struct that implements the `Consumer` trait for the `VehicleInterface`, with subscribers for the `left_tire` and `exhaust` events.
    /// The generated `VehicleConsumer<R>` struct will have fields for each event subscriber, and the `new` method will initialize these subscribers using the runtime's `Subscriber::new` method.
    /// The macro will also include error handling to ensure that subscriber creation failures are properly reported.
    #[cfg(doctest)]
    fn interface_consumer_macro() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_consumer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_consumer!(Vehicle, left_tire, Method<Tire>, exhaust, Method<Exhaust>);
    /// }
    /// ```
    /// This will fail to compile because the `interface_consumer!` macro does not support Method definitions and will produce a compile-time error indicating that Method definitions are not supported.
    #[cfg(doctest)]
    fn interface_consumer_macro_with_Method() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_consumer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_consumer!(Vehicle, left_tire, Field<Tire>, exhaust, Field<Exhaust>);
    /// }
    /// ```
    /// This will fail to compile because the `interface_consumer!` macro does not support Field definitions and will produce a compile-time error indicating that Field definitions are not supported.
    #[cfg(doctest)]
    fn interface_consumer_macro_with_Field() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_producer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_producer!(Vehicle, left_tire, Event<Tire>, exhaust, Event<Exhaust>);
    /// }
    /// ```
    /// This will generate a `VehicleProducer<R>` struct that implements the `Producer` trait for the
    /// `VehicleInterface`, with publishers for the `left_tire` and `exhaust` events.
    /// So it requires interface_common macro to be called before to generate the VehicleInterface struct
    /// and implement the Interface trait for it.
    #[cfg(doctest)]
    fn interface_producer_macro() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_producer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_producer!(Vehicle, left_tire, Method<Tire>, exhaust, Method<Exhaust>);
    /// }
    /// ```
    /// This will fail to compile because the `interface_producer!` macro does not support Method definitions and will produce a compile-time error indicating that Method definitions are not supported.
    #[cfg(doctest)]
    fn interface_producer_macro_with_Method() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_producer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_producer!(Vehicle, left_tire, Field<Tire>, exhaust, Field<Exhaust>);
    /// }
    /// ```
    /// This will fail to compile because the `interface_producer!` macro does not support Field definitions and will produce a compile-time error indicating that Field definitions are not supported.
    #[cfg(doctest)]
    fn interface_producer_macro_with_Field() {}
}
