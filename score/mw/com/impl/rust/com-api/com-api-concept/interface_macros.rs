/********************************************************************************
 * Copyright (c) 2025 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Apache License Version 2.0 which is available at
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: Apache-2.0
 ********************************************************************************/

#[doc(hidden)]
#[allow(unused_imports)]
pub use paste;

/// Main interface macro that generates Consumer, Producer, and OfferedProducer types
/// along with all necessary trait implementations.
///
/// Automatically generates unique type names from the identifier of macro invocation.
/// For an interface with identifier `{id}`, it generates:
/// - `{id}Interface` - Struct representing the interface with INTERFACE_ID constant
/// - `{id}Consumer<R>` - Consumer implementation with event subscribers
/// - `{id}Producer<R>` - Producer implementation
/// - `{id}OfferedProducer<R>` - Offered producer implementation with event publishers
/// - Implements the `Interface`, `Consumer`, `Producer`, and `OfferedProducer` traits
///  for the respective types.
/// - `Interface_ID` is generated by default as the module path + interface name,
/// but can be overridden by providing a custom UID as a second parameter to the macro.
///
/// Parameters:
/// - Keywords: `interface` followed by the interface identifier and a block of event definitions.
/// - `$id`: Simple identifier used for type name generation (e.g., Vehicle, Engine)
/// - `$event_name`: Event field name
/// - `$event_type`: Event data type
/// Example usage:
/// With default UID generation (module path + interface name):
/// ```ignore
/// mod abc {
///     use com_api_concept::interface;
///     interface!(
///         interface Vehicle {
///             left_tire: Event<Tire>,
///             exhaust: Event<Exhaust>,
///         }
///     );
/// }
/// ```
/// The generated code will include:
/// - `VehicleInterface` struct with `INTERFACE_ID = "abc::Vehicle"`
/// - `VehicleConsumer<R>` struct that implements `Consumer` trait for subscribing to "left_tire" and "exhaust" events.
/// - `VehicleProducer<R>` struct that implements `Producer` trait for producing "left_tire" and "exhaust" events.
/// - `VehicleOfferedProducer<R>` struct that implements `OfferedProducer` trait for offering "left_tire" and "exhaust" events.
///
/// With custom UID:
/// ```ignore
/// mod abc {
///     use com_api_concept::interface;
///     interface!(
///         interface Vehicle, "AbcInterface", {
///             left_tire: Event<Tire>,
///             exhaust: Event<Exhaust>,
///         }
///     );
/// }
/// ```
/// The generated code will include:
/// - `VehicleInterface` struct with `INTERFACE_ID = "AbcInterface"`
/// - `VehicleConsumer<R>` struct that implements `Consumer` trait for subscribing to "left_tire" and "exhaust" events.
/// - `VehicleProducer<R>` struct that implements `Producer` trait for producing "left_tire" and "exhaust" events.
/// - `VehicleOfferedProducer<R>` struct that implements `OfferedProducer` trait for offering "left_tire" and "exhaust" events.

#[macro_export]
macro_rules! interface {
    // Default unique ID based on the module path and interface name
    (interface $id:ident { $($event_name:ident : Event<$event_type:ty>),+ $(,)? }) => {
        $crate::interface_common!($id);
        $crate::interface_consumer!($id, $($event_name, Event<$event_type>),+);
        $crate::interface_producer!($id, $($event_name, Event<$event_type>),+);
    };

    // Custom unique ID provided by the user
    (interface $id:ident, $uid:expr, { $($event_name:ident : Event<$event_type:ty>),+ $(,)? }) => {
        $crate::interface_common!($id, $uid);
        $crate::interface_consumer!($id, $($event_name, Event<$event_type>),+);
        $crate::interface_producer!($id, $($event_name, Event<$event_type>),+);
    };

    (interface $id:ident { $($event_name:ident : Method<$event_type:ty>),+$(,)? }) => {
        compile_error!("Method definitions are not supported in this macro version. Please use Event<T> syntax for defining events.");
    };

    (interface $id:ident { $($event_name:ident : Field<$event_type:ty>),+$(,)? }) => {
        compile_error!("Field definitions are not supported in this macro version. Please use Event<T> syntax for defining events.");
    };
}

/// Macro to create a unique interface struct and implement the Interface trait for it.
///
/// Generates the INTERFACE_ID constant and associated Consumer/Producer types.
/// INTERFACE_ID is generated by default as the module path + interface name,
/// but can be overridden by providing a custom UID as a second parameter to the macro.
#[macro_export]
macro_rules! interface_common {
    // Default: auto ID = module path + type name
    ($id:ident) => {
        $crate::paste::paste!  {
            pub struct [<$id Interface>] {}
            impl com_api::Interface for [<$id Interface>] {
                const INTERFACE_ID: &'static str =
                    concat!(module_path!(), "::", stringify!($id));
                type Consumer<R: com_api::Runtime + ?Sized> = [<$id Consumer>]<R>;
                type Producer<R: com_api::Runtime + ?Sized> = [<$id Producer>]<R>;
            }
        }
    };
    // Explicit ID override
    ($id:ident, $uid:expr) => {
        $crate::paste::paste!  {
            pub struct [<$id Interface>] {}
            impl com_api::Interface for [<$id Interface>] {
                const INTERFACE_ID: &'static str = $uid;
                type Consumer<R: com_api::Runtime + ?Sized> = [<$id Consumer>]<R>;
                type Producer<R: com_api::Runtime + ?Sized> = [<$id Producer>]<R>;
            }
        }
    };
}

/// Macro to implement the Consumer trait for a given interface ID and its events.
///
/// Generates the Consumer struct with subscribers for each event.
#[macro_export]
macro_rules! interface_consumer {
    ($id:ident, $($event_name:ident, Event<$event_type:ty>),+$(,)?) => {
        $crate::paste::paste!  {
            pub struct [<$id Consumer>]<R: com_api::Runtime + ?Sized> {
                $(
                    pub $event_name: R::Subscriber<$event_type>,
                )+
            }

            impl<R: com_api::Runtime + ?Sized> com_api::Consumer<R> for [<$id Consumer>]<R> {
                fn new(instance_info: R::ConsumerInfo) -> Self {
                    [<$id Consumer>] {
                        $(
                            $event_name: R::Subscriber::new(
                                stringify!($event_name),
                                instance_info.clone()
                            ).expect(&format!("Failed to create subscriber for {}", stringify!($event_name))),
                        )+
                    }
                }
            }
        }
    };
}

/// Macro to implement the Producer and OfferedProducer traits for a given interface ID and its events.
///
/// Generates Producer and OfferedProducer structs with publishers for each event.
#[macro_export]
macro_rules! interface_producer {
    ($id:ident, $($event_name:ident, Event<$event_type:ty>),+$(,)?) => {
        $crate::paste::paste!  {
            pub struct [<$id Producer>]<R: com_api::Runtime + ?Sized> {
                _runtime: core::marker::PhantomData<R>,
                instance_info: R::ProviderInfo,
            }

            pub struct [<$id OfferedProducer>]<R: com_api::Runtime + ?Sized> {
                $(
                    pub $event_name: R::Publisher<$event_type>,
                )+
                instance_info: R::ProviderInfo,
            }

            impl<R: com_api::Runtime + ?Sized> com_api::Producer<R> for [<$id Producer>]<R> {
                type Interface = [<$id Interface>];
                type OfferedProducer = [<$id OfferedProducer>]<R>;
                fn offer(self) -> com_api::Result<Self::OfferedProducer> {
                    let offered = [<$id OfferedProducer>] {
                        $(
                            $event_name: R::Publisher::new(
                                stringify!($event_name),
                                self.instance_info.clone()
                            ).expect(&format!("Failed to create publisher for {}", stringify!($event_name))),
                        )+
                        instance_info: self.instance_info.clone(),
                    };
                    // Offer the service instance to make it discoverable
                    self.instance_info.offer_service()?;
                    Ok(offered)
                }

                fn new(instance_info: R::ProviderInfo) -> com_api::Result<Self> {
                    Ok([<$id Producer>] {
                        _runtime: core::marker::PhantomData,
                        instance_info,
                    })
                }
            }

            impl<R: com_api::Runtime + ?Sized> com_api::OfferedProducer<R> for [<$id OfferedProducer>]<R> {
                type Interface = [<$id Interface>];
                type Producer = [<$id Producer>]<R>;
                fn unoffer(self) -> com_api::Result<Self::Producer> {
                    let producer = [<$id Producer>] {
                        _runtime: core::marker::PhantomData,
                        instance_info: self.instance_info.clone(),
                    };
                    // Stop offering the service instance to withdraw it from system availability
                    self.instance_info.stop_offer_service()?;
                    Ok(producer)
                }
            }
        }
    };
}

mod tests {
    /// ```
    /// mod my_module {
    ///     use com_api::{interface,CommData, Reloc, ProviderInfo, Subscriber, Publisher};    
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     
    ///     interface!(
    ///         interface Vehicle {
    ///             left_tire: Event<Tire>,
    ///             exhaust: Event<Exhaust>,
    ///         }
    ///     );
    /// }
    /// ```
    /// This will generate the following types and trait implementations:
    /// - `VehicleInterface` struct with `INTERFACE_ID = "my_module::Vehicle"`
    /// - `VehicleConsumer<R>`, `VehicleProducer<R>`, `VehicleOfferedProducer<R>` with appropriate trait implementations for the Vehicle interface.
    #[cfg(doctest)]
    fn interface_macro_with_auto_id() {}

    /// ```
    /// mod my_module {
    ///     use com_api::{interface, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     
    ///     interface!(
    ///         interface Vehicle, "VehicleInterface", {
    ///             left_tire: Event<Tire>,
    ///             exhaust: Event<Exhaust>,
    ///         }
    ///     );
    /// }
    /// ```
    /// This will generate the following types and trait implementations:
    /// - `VehicleInterface` struct with `INTERFACE_ID = "VehicleInterface"`
    /// - `VehicleConsumer<R>`, `VehicleProducer<R>`, `VehicleOfferedProducer<R>` with appropriate trait implementations for the Vehicle interface.
    #[cfg(doctest)]
    fn interface_macro_with_custom_id() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     
    ///     interface!(
    ///         interface Vehicle, "VehicleInterface", {
    ///             left_tire: Method<Tire>,
    ///             exhaust: Method<Exhaust>,
    ///         }
    ///     );
    /// }
    /// ```
    /// This will fail to compile because the macro does not support Method definitions and will produce a compile-time error indicating that Method definitions are not supported.
    #[cfg(doctest)]
    fn interface_macro_with_Method() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     
    ///     interface!(
    ///         interface Vehicle {
    ///             left_tire: Field<Tire>,
    ///             exhaust: Field<Exhaust>,
    ///         }
    ///     );
    /// }
    /// ```
    /// This will fail to compile because the macro does not support Field definitions and will produce a compile-time error indicating that Field definitions are not supported.
    #[cfg(doctest)]
    fn interface_macro_with_Field() {}

    /// ```
    /// mod my_module {
    ///     use com_api::{interface_common, interface_consumer, interface_producer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_common!(Vehicle);
    ///     interface_consumer!(Vehicle, left_tire, Event<Tire>, exhaust, Event<Exhaust>);
    ///     interface_producer!(Vehicle, left_tire, Event<Tire>, exhaust, Event<Exhaust>);
    /// }
    /// ```
    /// This will generate a `VehicleInterface` struct with an `INTERFACE_ID` constant that is automatically generated as the module path plus the interface name (e.g., "my_module::Vehicle").
    /// It will also define associated `Consumer` and `Producer` types for the `VehicleInterface`.
    /// The `VehicleConsumer<R>` struct will implement the `Consumer` trait for the `VehicleInterface`, with subscribers for the `left_tire` and `exhaust` events.
    /// The `VehicleProducer<R>` struct will implement the `Producer` trait for the `VehicleInterface`, with publishers for the `left_tire` and `exhaust` events.
    #[cfg(doctest)]
    fn individual_common_macro_with_auto_id() {}

    /// ```
    /// mod my_module {
    ///     use com_api::{interface_common, interface_consumer, interface_producer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_common!(Vehicle, "CustomVehicleInterface");
    ///     interface_consumer!(Vehicle, left_tire, Event<Tire>, exhaust, Event<Exhaust>);
    ///     interface_producer!(Vehicle, left_tire, Event<Tire>, exhaust, Event<Exhaust>);
    /// }
    /// ```
    /// This will generate a `VehicleInterface` struct with an `INTERFACE_ID` constant set to "CustomVehicleInterface".
    /// It will also define associated `Consumer` and `Producer` types for the `VehicleInterface`.
    /// The `VehicleConsumer<R>` struct will implement the `Consumer` trait for the `VehicleInterface`, with subscribers for the `left_tire` and `exhaust` events.
    /// The `VehicleProducer<R>` struct will implement the `Producer` trait for the `VehicleInterface`, with publishers for the `left_tire` and `exhaust` events.
    #[cfg(doctest)]
    fn individual_macro_with_custom_id() {}

    /// ```compile_fail
    /// mod my_module {
    ///      use com_api::{interface_common, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///      #[derive(Debug, Reloc)]
    ///      #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///    impl CommData for Tire {
    ///        const ID: &'static str = "Tire";
    ///   }
    ///     #[derive(Debug, Reloc)]
    ///    #[repr(C)]
    ///   pub struct Exhaust {}
    ///   impl CommData for Exhaust {
    ///       const ID: &'static str = "Exhaust";
    ///   }
    ///     interface_common!(Vehicle, "CustomVehicleInterface", {
    ///         left_tire: Event<Tire>,
    ///         exhaust: Event<Exhaust>,
    ///     });
    /// }
    /// ```
    /// This will fail to compile because the `interface_common!` macro does not accept event definitions and will produce a compile-time error indicating that the macro does not support event definitions.
    #[cfg(doctest)]
    fn interface_common_macro_with_events() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_common, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_common!(Vehicle, "CustomVehicleInterface", {
    ///         left_tire: Method<Tire>,
    ///         exhaust: Method<Exhaust>,
    ///     });
    /// }
    /// ```
    /// This will fail to compile because the `interface_common!` macro does not accept method definitions and will produce a compile-time error indicating that the macro does not support method definitions.
    #[cfg(doctest)]
    fn interface_common_macro_with_methods() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_common, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_common!(Vehicle, "CustomVehicleInterface", {
    ///         left_tire: Field<Tire>,
    ///         exhaust: Field<Exhaust>,
    ///     });
    /// }
    /// ```
    /// This will fail to compile because the `interface_common!` macro does not accept field definitions and will produce a compile-time error indicating that the macro does not support field definitions.
    #[cfg(doctest)]
    fn interface_common_macro_with_fields() {}

    /// ```
    /// mod my_module {
    ///     use com_api::{interface_consumer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_consumer!(Vehicle, left_tire, Event<Tire>, exhaust, Event<Exhaust>);
    /// }
    /// ```
    /// This will generate a `VehicleConsumer<R>` struct that implements the `Consumer` trait for the `VehicleInterface`, with subscribers for the `left_tire` and `exhaust` events.
    /// The generated `VehicleConsumer<R>` struct will have fields for each event subscriber, and the `new` method will initialize these subscribers using the runtime's `Subscriber::new` method.
    /// The macro will also include error handling to ensure that subscriber creation failures are properly reported.
    #[cfg(doctest)]
    fn interface_consumer_macro() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_consumer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_consumer!(Vehicle, left_tire, Method<Tire>, exhaust, Method<Exhaust>);
    /// }
    /// ```
    /// This will fail to compile because the `interface_consumer!` macro does not support Method definitions and will produce a compile-time error indicating that Method definitions are not supported.
    #[cfg(doctest)]
    fn interface_consumer_macro_with_Method() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_consumer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///     
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_consumer!(Vehicle, left_tire, Field<Tire>, exhaust, Field<Exhaust>);
    /// }
    /// ```
    /// This will fail to compile because the `interface_consumer!` macro does not support Field definitions and will produce a compile-time error indicating that Field definitions are not supported.
    #[cfg(doctest)]
    fn interface_consumer_macro_with_Field() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_producer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_producer!(Vehicle, left_tire, Event<Tire>, exhaust, Event<Exhaust>);
    /// }
    /// ```
    /// This will generate a `VehicleProducer<R>` struct that implements the `Producer` trait for the
    /// `VehicleInterface`, with publishers for the `left_tire` and `exhaust` events.
    /// So it requires interface_common macro to be called before to generate the VehicleInterface struct
    /// and implement the Interface trait for it.
    #[cfg(doctest)]
    fn interface_producer_macro() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_producer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_producer!(Vehicle, left_tire, Method<Tire>, exhaust, Method<Exhaust>);
    /// }
    /// ```
    /// This will fail to compile because the `interface_producer!` macro does not support Method definitions and will produce a compile-time error indicating that Method definitions are not supported.
    #[cfg(doctest)]
    fn interface_producer_macro_with_Method() {}

    /// ```compile_fail
    /// mod my_module {
    ///     use com_api::{interface_producer, CommData, Reloc, ProviderInfo, Subscriber, Publisher};
    ///
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Tire { pub pressure: f32 }
    ///     impl CommData for Tire {
    ///         const ID: &'static str = "Tire";
    ///     }
    ///
    ///     #[derive(Debug, Reloc)]
    ///     #[repr(C)]
    ///     pub struct Exhaust {}
    ///     impl CommData for Exhaust {
    ///         const ID: &'static str = "Exhaust";
    ///     }
    ///     interface_producer!(Vehicle, left_tire, Field<Tire>, exhaust, Field<Exhaust>);
    /// }
    /// ```
    /// This will fail to compile because the `interface_producer!` macro does not support Field definitions and will produce a compile-time error indicating that Field definitions are not supported.
    #[cfg(doctest)]
    fn interface_producer_macro_with_Field() {}

}

#[cfg(test)]
#[allow(dead_code)]
#[allow(unused_imports)]
mod validation_tests {
    use crate::paste;

    #[test]
    fn test_interface_type_name_vehicle() {
        mod test_module {
            use com_api::{CommData, Reloc, ProviderInfo, Subscriber, Publisher};
            
            #[derive(Debug, Reloc)]
            #[repr(C)]
            pub struct Tire { pub pressure: f32 }
            impl CommData for Tire {
                const ID: &'static str = "Tire";
            }
            
            crate::interface!(
                interface Vehicle {
                    left_tire: Event<Tire>,
                }
            );
            
            pub fn validate() {
                let actual = std::any::type_name::<VehicleInterface>();
                // Extract only the last part of the type name (the original type)
                let type_name_only = actual.split("::").last().unwrap_or("");
                let expected = "VehicleInterface";
                assert_eq!(type_name_only, expected, "Type name mismatch for VehicleInterface");

                //id validation
                let interface_id = <VehicleInterface as com_api::Interface>::INTERFACE_ID;
                let expected_id = concat!(module_path!(), "::", "Vehicle");
                assert_eq!(interface_id, expected_id, "Interface ID mismatch for VehicleInterface");

                //wrong id validation
                let wrong_id = "SomeInterfaceID";
                assert_ne!(interface_id, wrong_id, "Interface ID should not match the wrong ID");

                //wrong type name validation
                let wrong_type_name = "SomeInterface";
                assert_ne!(type_name_only, wrong_type_name, "Type name should not match the wrong type name");
            }
        }
        test_module::validate();
    }

    #[test]
    fn test_interface_consumer_type_name() {
        mod test_module {
            use com_api::{CommData, Reloc, Consumer, ProviderInfo, Subscriber, Publisher, LolaRuntimeImpl as LolaRuntime};
            
            #[derive(Debug, Reloc, Clone)]
            #[repr(C)]
            pub struct Tire { pub pressure: f32 }
            impl CommData for Tire {
                const ID: &'static str = "Tire";
            }
            
            #[derive(Debug, Reloc, Clone)]
            #[repr(C)]
            pub struct Exhaust { pub temp: f32 }
            impl CommData for Exhaust {
                const ID: &'static str = "Exhaust";
            }
            
            crate::interface!(
                interface Vehicle {
                    left_tire: Event<Tire>,
                    exhaust: Event<Exhaust>,
                }
            );
            
            pub fn validate() {
                let actual = std::any::type_name::<VehicleConsumer<LolaRuntime>>();
                // Extract type name before generic parameters
                let type_name_only = actual.split('<').next()
                    .and_then(|s| s.split("::").last())
                    .unwrap_or("");
                let expected = "VehicleConsumer";
                assert_eq!(type_name_only, expected, "Type name mismatch for VehicleConsumer");

                // Verify struct fields exist
                assert!(std::mem::size_of::<VehicleConsumer<LolaRuntime>>() > 0,
                    "VehicleConsumer should have struct fields");

                //wrong type name validation
                let wrong_type_name = "SomeConsumer";
                assert_ne!(type_name_only, wrong_type_name, "Type name should not match the wrong type name");
            }
        }
        test_module::validate();
    }

    #[test]
    fn test_interface_producer_type_name() {
        mod test_module {
            use com_api::{CommData, Reloc, Producer, ProviderInfo, Subscriber, Publisher, LolaRuntimeImpl as LolaRuntime};
            
            #[derive(Debug, Reloc, Clone)]
            #[repr(C)]
            pub struct Tire { pub pressure: f32 }
            impl CommData for Tire {
                const ID: &'static str = "Tire";
            }
            
            crate::interface!(
                interface Engine {
                    rpm: Event<Tire>,
                }
            );
            
            pub fn validate() {
                let actual = std::any::type_name::<EngineProducer<LolaRuntime>>();
                // Extract type name before generic parameters
                let type_name_only = actual.split('<').next()
                    .and_then(|s| s.split("::").last())
                    .unwrap_or("");
                let expected = "EngineProducer";
                assert_eq!(type_name_only, expected, "Type name mismatch for EngineProducer");

                //wrong type name validation
                let wrong_type_name = "SomeProducer";
                assert_ne!(type_name_only, wrong_type_name, "Type name should not match the wrong type name");
            }
        }
        test_module::validate();
    }

    #[test]
    fn test_interface_offered_producer_type_name() {
        mod test_module {
            use com_api::{CommData, Reloc, Producer, OfferedProducer ,ProviderInfo, Subscriber, Publisher, LolaRuntimeImpl as LolaRuntime};
            
            #[derive(Debug, Reloc, Clone)]
            #[repr(C)]
            pub struct Tire { pub pressure: f32 }
            impl CommData for Tire {
                const ID: &'static str = "Tire";
            }
            
            crate::interface!(
                interface Transmission {
                    gear: Event<Tire>,
                }
            );
            
            pub fn validate() {
                let actual = std::any::type_name::<TransmissionOfferedProducer<LolaRuntime>>();
                // Extract type name before generic parameters
                let type_name_only = actual.split('<').next()
                    .and_then(|s| s.split("::").last())
                    .unwrap_or("");
                let expected = "TransmissionOfferedProducer";
                assert_eq!(type_name_only, expected, "Type name mismatch for TransmissionOfferedProducer");

                //wrong type name validation
                let wrong_type_name = "SomeOfferedProducer";
                assert_ne!(type_name_only, wrong_type_name, "Type name should not match the wrong type name");

                // Verify struct fields exist for publishers
                assert!(std::mem::size_of::<TransmissionOfferedProducer<LolaRuntime>>() > 0,
                    "TransmissionOfferedProducer should have publisher fields");
            }
        }
        test_module::validate();
    }

    #[test]
    fn test_interface_with_custom_id_validation() {
        mod test_module {
            use com_api::{CommData, Reloc, Producer, ProviderInfo, Subscriber, Publisher, LolaRuntimeImpl as LolaRuntime, Interface};
            
            #[derive(Debug, Reloc, Clone)]
            #[repr(C)]
            pub struct Tire { pub pressure: f32 }
            impl CommData for Tire {
                const ID: &'static str = "Tire";
            }
            
            crate::interface!(
                interface Battery, "com.example.Battery", {
                    voltage: Event<Tire>,
                }
            );
            
            pub fn validate() {
                let interface_id = <BatteryInterface as Interface>::INTERFACE_ID;
                let expected_id = "com.example.Battery";
                assert_eq!(interface_id, expected_id, 
                    "Custom interface ID should match provided UID");

                let actual_type = std::any::type_name::<BatteryInterface>();
                let type_name_only = actual_type.split("::").last().unwrap_or("");
                assert_eq!(type_name_only, "BatteryInterface",
                    "Type name should still be BatteryInterface regardless of custom ID");

                //wrong type name validation
                let wrong_type_name = "SomeInterface";
                assert_ne!(type_name_only, wrong_type_name, "Type name should not match the wrong type name");
            }
        }
        test_module::validate();
    }

    #[test]
    fn test_interface_with_multiple_events_validation() {
        mod test_module {
            use com_api::{CommData, Reloc, Producer, ProviderInfo, Subscriber, Publisher, LolaRuntimeImpl as LolaRuntime, Interface};
            
            #[derive(Debug, Reloc, Clone)]
            #[repr(C)]
            pub struct Event1Data { pub value: i32 }
            impl CommData for Event1Data {
                const ID: &'static str = "Event1Data";
            }
            
            #[derive(Debug, Reloc, Clone)]
            #[repr(C)]
            pub struct Event2Data { pub value: f64 }
            impl CommData for Event2Data {
                const ID: &'static str = "Event2Data";
            }
            
            #[derive(Debug, Reloc, Clone)]
            #[repr(C)]
            pub struct Event3Data { pub value: bool }
            impl CommData for Event3Data {
                const ID: &'static str = "Event3Data";
            }
            
            crate::interface!(
                interface MultiEvent {
                    event_one: Event<Event1Data>,
                    event_two: Event<Event2Data>,
                    event_three: Event<Event3Data>,
                }
            );
            
            pub fn validate() {
                // Validate interface
                let interface_id = <MultiEventInterface as Interface>::INTERFACE_ID;
                assert!(interface_id.contains("MultiEvent"),
                    "Interface ID should contain MultiEvent");

                // Validate Consumer with multiple event subscribers
                let consumer_type = std::any::type_name::<MultiEventConsumer<LolaRuntime>>();
                assert!(consumer_type.contains("MultiEventConsumer"),
                    "MultiEventConsumer type should be generated");

                // Validate Producer with multiple event publishers
                let producer_type = std::any::type_name::<MultiEventProducer<LolaRuntime>>();
                assert!(producer_type.contains("MultiEventProducer"),
                    "MultiEventProducer type should be generated");

                // Validate OfferedProducer
                let offered_type = std::any::type_name::<MultiEventOfferedProducer<LolaRuntime>>();
                assert!(offered_type.contains("MultiEventOfferedProducer"),
                    "MultiEventOfferedProducer type should be generated");
            }
        }
        test_module::validate();
    }

    #[test]
    fn test_interface_type_consistency_across_traits() {
        mod test_module {
            use com_api::{CommData, Reloc, Producer, ProviderInfo, Subscriber, Publisher, LolaRuntimeImpl as LolaRuntime, Interface};
            
            #[derive(Debug, Reloc, Clone)]
            #[repr(C)]
            pub struct Tire { pub pressure: f32 }
            impl CommData for Tire {
                const ID: &'static str = "Tire";
            }
            
            crate::interface!(
                interface Suspension {
                    travel: Event<Tire>,
                }
            );
            
            pub fn validate() {
                // Verify that Consumer and Producer reference the same Interface type
                let interface_id = <SuspensionInterface as Interface>::INTERFACE_ID;
                
                // Type names should be consistent
                let suspension_interface_type = std::any::type_name::<SuspensionInterface>();
                let consumer_type = std::any::type_name::<SuspensionConsumer<LolaRuntime>>();
                let producer_type = std::any::type_name::<SuspensionProducer<LolaRuntime>>();
                let offered_type = std::any::type_name::<SuspensionOfferedProducer<LolaRuntime>>();

                assert!(suspension_interface_type.contains("SuspensionInterface"),
                    "Interface type name should contain SuspensionInterface");
                assert!(consumer_type.contains("SuspensionConsumer"),
                    "Consumer type name should contain SuspensionConsumer");
                assert!(producer_type.contains("SuspensionProducer"),
                    "Producer type name should contain SuspensionProducer");
                assert!(offered_type.contains("SuspensionOfferedProducer"),
                    "OfferedProducer type name should contain SuspensionOfferedProducer");

                // All should be in the same module scope
                assert_eq!(interface_id, concat!(module_path!(), "::", "Suspension"),
                    "Interface ID should be auto-generated from module path and interface name");
            }
        }
        test_module::validate();
    }

    #[test]
    fn test_interface_invalid_id_mismatch() {
        mod test_module {
            use com_api::{CommData, Reloc, Producer, ProviderInfo, Subscriber, Publisher, LolaRuntimeImpl as LolaRuntime, Interface};
            
            #[derive(Debug, Reloc, Clone)]
            #[repr(C)]
            pub struct Tire { pub pressure: f32 }
            impl CommData for Tire {
                const ID: &'static str = "Tire";
            }
            
            crate::interface!(
                interface Cooling {
                    temperature: Event<Tire>,
                }
            );
            
            pub fn validate() {
                let interface_id = <CoolingInterface as Interface>::INTERFACE_ID;
                let wrong_id = "WrongCoolingID";
                
                assert_ne!(interface_id, wrong_id,
                    "Interface ID should not match incorrect ID");
                
                let wrong_type = "CoolingProducer";
                let actual_type = std::any::type_name::<CoolingInterface>();
                let type_name_only = actual_type.split("::").last().unwrap_or("");
                
                assert_ne!(type_name_only, wrong_type,
                    "CoolingInterface type name should not match CoolingProducer");
            }
        }
        test_module::validate();
    }

    #[test]
    fn test_interface_naming_convention_validation() {
        mod test_module {
            use com_api::{CommData, Reloc, Producer, ProviderInfo, Subscriber, Publisher, LolaRuntimeImpl as LolaRuntime, Interface};
            
            #[derive(Debug, Reloc, Clone)]
            #[repr(C)]
            pub struct Data { pub value: u32 }
            impl CommData for Data {
                const ID: &'static str = "Data";
            }
            
            crate::interface!(
                interface ABS {
                    status: Event<Data>,
                }
            );
            
            pub fn validate() {
                // Verify naming conventions for all generated types
                let interface = std::any::type_name::<ABSInterface>();
                let consumer = std::any::type_name::<ABSConsumer<LolaRuntime>>();
                let producer = std::any::type_name::<ABSProducer<LolaRuntime>>();
                let offered = std::any::type_name::<ABSOfferedProducer<LolaRuntime>>();

                // Extract type names before generic parameters and module path
                let interface_name = interface.split("::").last().unwrap_or("");
                let consumer_name = consumer.split('<').next()
                    .and_then(|s| s.split("::").last())
                    .unwrap_or("");
                let producer_name = producer.split('<').next()
                    .and_then(|s| s.split("::").last())
                    .unwrap_or("");
                let offered_name = offered.split('<').next()
                    .and_then(|s| s.split("::").last())
                    .unwrap_or("");

                // Validate naming pattern: {InterfaceName}{Suffix}
                assert_eq!(interface_name, "ABSInterface", 
                    "Interface should follow pattern {{Name}}Interface");
                assert_eq!(consumer_name, "ABSConsumer", 
                    "Consumer should follow pattern {{Name}}Consumer");
                assert_eq!(producer_name, "ABSProducer", 
                    "Producer should follow pattern {{Name}}Producer");
                assert_eq!(offered_name, "ABSOfferedProducer", 
                    "OfferedProducer should follow pattern {{Name}}OfferedProducer");
            }
        }
        test_module::validate();
    }
}
